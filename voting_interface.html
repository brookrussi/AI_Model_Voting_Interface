<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Response Voting</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Deloitte Brand Colors */
            --deloitte-green: #86BC25;
            --deloitte-blue: #0076A8;
            --deloitte-grey: #62666A;
            --deloitte-light-grey: #F4F4F4;
            --deloitte-dark-grey: #3D4043;

            /* Modern UI Colors */
            --background: #FAFBFC;
            --surface: #FFFFFF;
            --surface-hover: #F8F9FA;
            --border-light: #E8EAED;
            --border-medium: #DADCE0;
            --text-primary: #202124;
            --text-secondary: #5F6368;
            --text-tertiary: #80868B;
            --shadow-light: 0 1px 3px rgba(60, 64, 67, 0.08);
            --shadow-medium: 0 4px 12px rgba(60, 64, 67, 0.15);
            --radius: 8px;
            --radius-large: 12px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--background) 0%, #F0F2F5 100%);
            min-height: 100vh;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: var(--surface);
            padding: 48px 32px;
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-medium);
            border: 1px solid var(--border-light);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--deloitte-green) 0%, var(--deloitte-blue) 100%);
        }

        .header h1 {
            color: var(--text-primary);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 12px;
            letter-spacing: -0.025em;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.125rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .conversation-select {
            margin-bottom: 30px;
            text-align: center;
        }

        .conversation-select select {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            min-width: 300px;
        }

        .turn {
            background: var(--surface);
            margin-bottom: 48px;
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-medium);
            border: 1px solid var(--border-light);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .turn:hover {
            box-shadow: 0 8px 24px rgba(60, 64, 67, 0.12);
        }

        .turn-header {
            background: linear-gradient(135deg, var(--deloitte-blue) 0%, var(--deloitte-green) 100%);
            color: white;
            padding: 32px;
            position: relative;
        }

        .turn-number {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .user-prompt {
            font-size: 1.25rem;
            font-weight: 500;
            line-height: 1.4;
            margin: 0;
        }

        .responses-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            padding: 32px;
            background: var(--surface);
        }

        /* Responsive breakpoints for smaller screens */
        @media (max-width: 1200px) {
            .responses-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 24px;
            }
        }

        @media (max-width: 768px) {
            .responses-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        .response-card {
            border: 2px solid var(--border-light);
            border-radius: var(--radius);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            background: var(--surface);
            position: relative;
        }

        .response-card:hover {
            border-color: var(--deloitte-blue);
            transform: translateY(-4px);
            box-shadow: var(--shadow-medium);
        }

        .response-card.selected {
            border-color: var(--deloitte-green);
            background: linear-gradient(135deg, rgba(134, 188, 37, 0.05) 0%, rgba(134, 188, 37, 0.02) 100%);
            box-shadow: 0 0 0 4px rgba(134, 188, 37, 0.1);
        }

        .response-header {
            background: var(--deloitte-light-grey);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .response-label {
            font-weight: 600;
            font-size: 1.125rem;
            color: var(--text-primary);
            letter-spacing: -0.025em;
        }

        .vote-count {
            background: linear-gradient(135deg, var(--deloitte-blue) 0%, var(--deloitte-green) 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.025em;
        }

        .response-text {
            padding: 24px;
            line-height: 1.6;
            color: var(--text-primary);
            font-size: 0.9375rem;
        }

        .notes-section {
            padding: 24px 32px;
            border-top: 1px solid var(--border-light);
            background: linear-gradient(135deg, rgba(134, 188, 37, 0.08) 0%, rgba(134, 188, 37, 0.04) 100%);
            border-left: 4px solid var(--deloitte-green);
        }

        .notes-textarea {
            width: 100%;
            min-height: 100px;
            padding: 16px;
            border: 2px solid rgba(134, 188, 37, 0.3);
            border-radius: var(--radius);
            font-size: 0.9375rem;
            font-family: inherit;
            resize: vertical;
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-primary);
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(134, 188, 37, 0.1);
        }

        .notes-textarea::placeholder {
            color: var(--text-tertiary);
            font-style: italic;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: var(--deloitte-green);
            box-shadow: 0 0 0 4px rgba(134, 188, 37, 0.2), 0 2px 12px rgba(134, 188, 37, 0.15);
        }

        .notes-textarea:disabled {
            background: rgba(244, 244, 244, 0.8);
            color: var(--text-secondary);
            cursor: not-allowed;
            border-color: rgba(134, 188, 37, 0.2);
        }

        .voting-controls {
            text-align: center;
            padding: 32px;
            background: var(--surface);
            border-top: 1px solid var(--border-light);
        }

        .vote-button {
            background: linear-gradient(135deg, var(--deloitte-green) 0%, #9BC53D 100%);
            color: white;
            border: none;
            padding: 16px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-light);
            letter-spacing: 0.025em;
            min-width: 160px;
        }

        .vote-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
            background: linear-gradient(135deg, #7BA823 0%, var(--deloitte-green) 100%);
        }

        .vote-button:disabled {
            background: var(--deloitte-grey);
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-light);
        }

        .success-message {
            background: linear-gradient(135deg, rgba(134, 188, 37, 0.1) 0%, rgba(134, 188, 37, 0.05) 100%);
            color: var(--deloitte-green);
            padding: 16px 24px;
            border-radius: var(--radius);
            margin: 20px 0;
            text-align: center;
            border: 1px solid rgba(134, 188, 37, 0.3);
            font-weight: 500;
        }

        .error-message {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(239, 68, 68, 0.05) 100%);
            color: #dc2626;
            padding: 16px 24px;
            border-radius: var(--radius);
            margin: 20px 0;
            text-align: center;
            border: 1px solid rgba(239, 68, 68, 0.3);
            font-weight: 500;
        }

        .loading {
            text-align: center;
            padding: 64px;
            color: var(--text-secondary);
            font-size: 1.125rem;
            font-weight: 500;
        }

        .progress-bar {
            background: #e2e8f0;
            height: 8px;
            border-radius: 4px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: #4299e1;
            height: 100%;
            transition: width 0.3s ease;
        }

        .stats {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .stat-item {
            padding: 10px;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #4299e1;
        }

        .stat-label {
            font-size: 14px;
            color: #718096;
        }

        .final-submit-section {
            background: var(--surface);
            margin-top: 48px;
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-medium);
            border: 1px solid var(--border-light);
            overflow: hidden;
        }

        .final-submit-content {
            padding: 48px 32px;
            text-align: center;
            background: linear-gradient(135deg, rgba(134, 188, 37, 0.05) 0%, rgba(134, 188, 37, 0.02) 100%);
        }

        .final-submit-content h3 {
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .final-submit-content p {
            color: var(--text-secondary);
            font-size: 1rem;
            margin-bottom: 32px;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .final-submit-button {
            background: linear-gradient(135deg, var(--deloitte-green) 0%, #9BC53D 100%);
            color: white;
            border: none;
            padding: 20px 48px;
            font-size: 1.125rem;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-medium);
            letter-spacing: 0.025em;
            min-width: 200px;
        }

        .final-submit-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(60, 64, 67, 0.2);
            background: linear-gradient(135deg, #7BA823 0%, var(--deloitte-green) 100%);
        }

        .final-submit-button:disabled {
            background: var(--deloitte-grey);
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-light);
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .responses-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 10px;
            }

            .final-submit-content {
                padding: 32px 24px;
            }

            .final-submit-button {
                padding: 16px 32px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>ðŸ¤– Compare AI Model Performance</h1>
            <p>Help evaluate which AI models give the best responses by voting on real conversations. Model names are hidden so you judge purely on quality, not brand recognition.</p>
        </header>

        <!-- Conversation auto-loads - no user selection needed -->

        <div id="stats" class="stats" style="display: none;">
            <h3>Voting Progress</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div id="totalTurns" class="stat-number">0</div>
                    <div class="stat-label">Total Turns</div>
                </div>
                <div class="stat-item">
                    <div id="votedTurns" class="stat-number">0</div>
                    <div class="stat-label">Voted On</div>
                </div>
                <div class="stat-item">
                    <div id="remainingTurns" class="stat-number">0</div>
                    <div class="stat-label">Remaining</div>
                </div>
            </div>
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
            </div>
        </div>

        <div id="loading" class="loading">
            Loading conversations...
        </div>

        <div id="votingArea" style="display: none;"></div>

        <!-- Final submit button that appears after all turns -->
        <div id="finalSubmitSection" class="final-submit-section" style="display: none;">
            <div class="final-submit-content">
                <h3>Ready to Submit All Votes?</h3>
                <p>Please make sure you've voted on all turns and left any notes you'd like to share.</p>
                <button id="finalSubmitBtn" class="final-submit-button" onclick="submitAllVotes()" disabled>
                    Submit All Votes
                </button>
                <div id="finalSubmitMessage"></div>
            </div>
        </div>
    </div>

    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://tmkobgbqrbaascebzbny.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRta29iZ2JxcmJhYXNjZWJ6Ym55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUyMjg3NTQsImV4cCI6MjA4MDgwNDc1NH0.YYa6MZbpspu3q27rTGZ2RZvJnhm0JIHOiih8IWDieFU';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Global state
        let currentConversation = null;
        let currentTurns = [];
        let userVotes = new Set(); // Track which turns user has voted on
        let voterSession = generateSessionId();

        // Generate a unique session ID for this voting session
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Auto-load the active conversation on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await loadActiveConversation();
        });

        // Load the active conversation automatically
        async function loadActiveConversation() {
            try {
                // Get the most recent conversation (you control which one this is)
                const { data: conversations, error } = await supabase
                    .from('conversations')
                    .select('id, title, imported_at')
                    .order('imported_at', { ascending: false })
                    .limit(1);

                if (error) throw error;

                if (conversations && conversations.length > 0) {
                    const activeConversation = conversations[0];
                    document.getElementById('loading').textContent = `Loading: ${activeConversation.title}...`;
                    await loadConversationTurns(activeConversation.id);
                } else {
                    showError('No conversations available for voting.');
                }
            } catch (error) {
                showError('Failed to load conversation: ' + error.message);
            }
        }

        // Load turns for selected conversation
        async function loadConversationTurns(conversationId) {
            try {
                showLoading('Loading conversation turns...');

                const { data: turns, error } = await supabase
                    .from('voting_interface')
                    .select('*')
                    .eq('conversation_id', conversationId)
                    .order('turn_number');

                if (error) throw error;

                // Group responses by turn
                const turnMap = {};
                turns.forEach(turn => {
                    if (!turnMap[turn.turn_id]) {
                        turnMap[turn.turn_id] = {
                            turn_id: turn.turn_id,
                            turn_number: turn.turn_number,
                            user_prompt: turn.user_prompt,
                            responses: []
                        };
                    }

                    turnMap[turn.turn_id].responses.push({
                        position: turn.position,
                        text: turn.response_text,
                        current_votes: turn.current_votes
                    });
                });

                currentTurns = Object.values(turnMap);
                currentTurns.forEach(turn => {
                    turn.responses.sort((a, b) => a.position.localeCompare(b.position));
                });

                // Reset voting state and check for existing votes
                userVotes.clear();
                await loadExistingVotes();

                renderVotingInterface();
                updateStats();
                hideLoading();

            } catch (error) {
                showError('Failed to load conversation: ' + error.message);
            }
        }

        // Render the voting interface
        function renderVotingInterface() {
            const votingArea = document.getElementById('votingArea');
            votingArea.innerHTML = '';
            votingArea.style.display = 'block';

            currentTurns.forEach((turn, index) => {
                const turnElement = createTurnElement(turn, index);
                votingArea.appendChild(turnElement);
            });

            document.getElementById('stats').style.display = 'block';
            document.getElementById('finalSubmitSection').style.display = 'block';
            updateFinalSubmitButton();
        }

        // Create HTML element for a turn
        function createTurnElement(turn, turnIndex) {
            const turnDiv = document.createElement('div');
            turnDiv.className = 'turn';
            turnDiv.id = `turn-${turn.turn_id}`;

            const hasVoted = userVotes.has(turn.turn_id);

            turnDiv.innerHTML = `
                <div class="turn-header">
                    <div class="turn-number">Turn ${turn.turn_number}</div>
                    <div class="user-prompt">${formatMarkdown(turn.user_prompt)}</div>
                </div>
                <div class="responses-grid">
                    ${turn.responses.map(response => `
                        <div class="response-card" data-position="${response.position}" onclick="selectResponse('${turn.turn_id}', '${response.position}')">
                            <div class="response-header">
                                <div class="response-label">Response ${response.position}</div>
                            </div>
                            <div class="response-text">${formatMarkdown(response.text)}</div>
                        </div>
                    `).join('')}
                </div>
                <div class="notes-section">
                    <textarea
                        class="notes-textarea"
                        id="notes-${turn.turn_id}"
                        placeholder="What did you like about the response you chose? Is there anything from the other responses that you liked?"
                        rows="4"
                        ${hasVoted ? 'disabled style="opacity: 0.6;"' : ''}></textarea>
                </div>
                <div id="message-${turn.turn_id}"></div>
            `;

            return turnDiv;
        }

        // Global object to track user selections for each turn
        let userSelections = {};

        // Select a response (highlight it)
        function selectResponse(turnId, position) {
            // Don't allow selection if already voted on this turn
            if (userVotes.has(turnId)) {
                return;
            }

            // Remove previous selections for this turn
            const turnElement = document.getElementById(`turn-${turnId}`);
            turnElement.querySelectorAll('.response-card').forEach(card => {
                card.classList.remove('selected');
            });

            // Add selection to clicked card
            const selectedCard = turnElement.querySelector(`[data-position="${position}"]`);
            selectedCard.classList.add('selected');

            // Store the selection
            userSelections[turnId] = position;

            // Update final submit button state and progress
            updateFinalSubmitButton();
            updateStats();
        }

        // Load existing votes for the current session
        async function loadExistingVotes() {
            try {
                const turnIds = currentTurns.map(turn => turn.turn_id);
                const { data: existingVotes, error } = await supabase
                    .from('votes')
                    .select('turn_id, position, notes')
                    .eq('voter_session', voterSession)
                    .in('turn_id', turnIds);

                if (error) throw error;

                // Mark turns as voted
                existingVotes?.forEach(vote => {
                    userVotes.add(vote.turn_id);
                });

            } catch (error) {
                console.error('Error loading existing votes:', error);
            }
        }

        // Check if user has already voted on this turn
        async function checkExistingVote(turnId) {
            try {
                const { data, error } = await supabase
                    .from('votes')
                    .select('id, position, notes')
                    .eq('turn_id', turnId)
                    .eq('voter_session', voterSession)
                    .single();

                if (error && error.code !== 'PGRST116') throw error; // PGRST116 = not found, which is expected

                return data; // null if no vote found, vote object if found
            } catch (error) {
                console.error('Error checking existing vote:', error);
                return null;
            }
        }

        // Check if all turns have been selected
        function updateFinalSubmitButton() {
            const finalSubmitBtn = document.getElementById('finalSubmitBtn');
            if (!finalSubmitBtn) return;

            // Count selected turns (not yet voted on)
            const selectedTurns = Object.keys(userSelections).length;
            const totalUnvotedTurns = currentTurns.length - userVotes.size;

            // Enable button only if user has made selections for all unvoted turns
            const allTurnsSelected = selectedTurns >= totalUnvotedTurns && totalUnvotedTurns > 0;

            finalSubmitBtn.disabled = !allTurnsSelected;

            if (userVotes.size === currentTurns.length) {
                // All turns voted, hide the button
                document.getElementById('finalSubmitSection').style.display = 'none';
            } else if (allTurnsSelected) {
                finalSubmitBtn.textContent = `Submit ${selectedTurns} Vote${selectedTurns > 1 ? 's' : ''}`;
            } else {
                finalSubmitBtn.textContent = 'Select responses for all turns';
            }
        }

        // Submit all pending votes
        async function submitAllVotes() {
            const finalSubmitBtn = document.getElementById('finalSubmitBtn');
            const messageDiv = document.getElementById('finalSubmitMessage');

            finalSubmitBtn.disabled = true;
            finalSubmitBtn.textContent = 'Submitting...';
            messageDiv.innerHTML = '';

            const votesToSubmit = [];
            const errors = [];

            // Prepare all votes for submission
            for (const [turnId, position] of Object.entries(userSelections)) {
                // Skip if already voted on this turn
                if (userVotes.has(turnId)) continue;

                // Check if user already voted on this turn (double-check)
                const existingVote = await checkExistingVote(turnId);
                if (existingVote) {
                    errors.push(`You already voted on turn ${turnId}`);
                    continue;
                }

                // Get notes for this turn
                const notesTextarea = document.getElementById(`notes-${turnId}`);
                const notes = notesTextarea ? notesTextarea.value.trim() : '';

                votesToSubmit.push({
                    turn_id: turnId,
                    position: position,
                    voter_session: voterSession,
                    notes: notes
                });
            }

            if (errors.length > 0) {
                messageDiv.innerHTML = `<div class="error-message">${errors.join('<br>')}</div>`;
                finalSubmitBtn.disabled = false;
                finalSubmitBtn.textContent = 'Submit All Votes';
                return;
            }

            if (votesToSubmit.length === 0) {
                messageDiv.innerHTML = `<div class="error-message">No new votes to submit.</div>`;
                finalSubmitBtn.disabled = false;
                finalSubmitBtn.textContent = 'Submit All Votes';
                return;
            }

            try {
                // Submit all votes in a batch
                const { error } = await supabase
                    .from('votes')
                    .insert(votesToSubmit);

                if (error) {
                    if (error.code === '23505' || error.message.includes('unique_vote_per_session_per_turn')) {
                        throw new Error('Some votes were already submitted. Please refresh the page.');
                    }
                    throw error;
                }

                // Mark all submitted votes as completed
                votesToSubmit.forEach(vote => {
                    userVotes.add(vote.turn_id);

                    // Disable notes textarea
                    const notesTextarea = document.getElementById(`notes-${vote.turn_id}`);
                    if (notesTextarea) {
                        notesTextarea.disabled = true;
                        notesTextarea.style.opacity = '0.6';
                    }

                    // Show success message for each turn
                    showTurnMessage(vote.turn_id, 'âœ… Vote recorded!', 'success');
                });

                // Clear selections
                userSelections = {};

                // Update UI
                messageDiv.innerHTML = `<div class="success-message">âœ… Successfully submitted ${votesToSubmit.length} vote${votesToSubmit.length > 1 ? 's' : ''}!</div>`;
                updateStats();
                updateFinalSubmitButton();

                // Vote counts are hidden to prevent bias
                // No need to refresh counts since they're not displayed

            } catch (error) {
                messageDiv.innerHTML = `<div class="error-message">Failed to submit votes: ${error.message}</div>`;
                finalSubmitBtn.disabled = false;
                finalSubmitBtn.textContent = 'Submit All Votes';
                console.error('Error submitting votes:', error);
            }
        }

        // Refresh vote counts for a turn
        async function refreshVoteCounts(turnId) {
            try {
                const { data: votes, error } = await supabase
                    .from('voting_interface')
                    .select('position, current_votes')
                    .eq('turn_id', turnId);

                if (error) throw error;

                votes.forEach(vote => {
                    const voteCountElement = document.querySelector(
                        `#turn-${turnId} [data-position="${vote.position}"] .vote-count`
                    );
                    if (voteCountElement) {
                        voteCountElement.textContent = `${vote.current_votes} votes`;
                    }
                });

            } catch (error) {
                console.error('Failed to refresh vote counts:', error);
            }
        }

        // Update statistics display
        function updateStats() {
            const totalTurns = currentTurns.length;
            const votedTurns = userVotes.size;

            // Count selections that haven't been voted on yet
            const pendingSelections = Object.keys(userSelections).filter(turnId => !userVotes.has(turnId)).length;

            // Total progress includes voted turns and pending selections
            const totalProgress = votedTurns + pendingSelections;
            const remainingTurns = totalTurns - totalProgress;
            const progressPercent = totalTurns > 0 ? (totalProgress / totalTurns) * 100 : 0;

            document.getElementById('totalTurns').textContent = totalTurns;
            document.getElementById('votedTurns').textContent = votedTurns;
            document.getElementById('remainingTurns').textContent = Math.max(0, remainingTurns);
            document.getElementById('progressFill').style.width = `${progressPercent}%`;
        }

        // Show message for a specific turn
        function showTurnMessage(turnId, message, type) {
            const messageDiv = document.getElementById(`message-${turnId}`);
            messageDiv.innerHTML = `<div class="${type}-message">${message}</div>`;
            setTimeout(() => {
                messageDiv.innerHTML = '';
            }, 3000);
        }

        // Utility functions
        function showError(message) {
            const votingArea = document.getElementById('votingArea');
            votingArea.innerHTML = `<div class="error-message">${message}</div>`;
            votingArea.style.display = 'block';
            hideLoading();
        }

        function showLoading(message = 'Loading...') {
            const loading = document.getElementById('loading');
            loading.textContent = message;
            loading.style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Clean and format response text
        function formatMarkdown(text) {
            if (!text) return '';

            // Remove reasoning sections (GPT internal thinking)
            let cleaned = text
                .replace(/### Reasoning[\s\S]*?(?=###|$)/gi, '') // Remove ### Reasoning sections
                .replace(/##+ Reasoning[\s\S]*?(?=##|$)/gi, '')  // Remove ## Reasoning sections
                .replace(/\*\*Reasoning\*\*[\s\S]*?(?=\*\*|$)/gi, '') // Remove **Reasoning** sections
                .trim();

            // First escape HTML to prevent XSS
            let formatted = escapeHtml(cleaned);

            // Convert markdown formatting
            formatted = formatted
                // Bold text: **text** or __text__
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
                .replace(/__([^_]+)__/g, '<strong>$1</strong>')

                // Italic text: *text* or _text_
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')
                .replace(/_([^_]+)_/g, '<em>$1</em>')

                // Convert bullet points
                .replace(/^[\s]*[\*\-\+][\s]+(.+)$/gm, '<li>$1</li>')

                // Convert numbered lists
                .replace(/^[\s]*(\d+)\.[\s]+(.+)$/gm, '<li>$2</li>')

                // Wrap consecutive <li> elements in <ul>
                .replace(/(<li>.*?<\/li>)(\s*<li>.*?<\/li>)*/g, function(match) {
                    return '<ul>' + match + '</ul>';
                })

                // Convert line breaks to <br>
                .replace(/\n/g, '<br>');

            return formatted;
        }
    </script>
</body>
</html>